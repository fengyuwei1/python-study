# 目标检测

## 1.什么是目标检测

目标检测：位置+类别

主流的目标检测，都是以矩阵框的形式进行输出的。

语义分割：更高精度

## 2.目标检测数据集 

介绍常见的数据集

制作自己的数据集

### 2.1 VOC数据集

1.VOC 2007

2.VOC 2012

训练集-图片  训练集-标注

测试集-图片  测试集-标注(结果)

下载数据

### 2.2 voc 2007数据集的标注

https://www.gifgit.com/image/rectangle-tool --- 在线图片查看网址

![image-20240915215046060](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240915215046060.png)

### 2.3 coco数据集

![image-20240916152709168](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240916152709168.png)

## 3.标注自己的数据集

### 3.1 标注工具

https://www.makesense.ai/

https://cvat.org/

### 3.2 实现代码

```py
import torchvision
from PIL import ImageDraw
coco_dataset = torchvision.datasets.CocoDetection(root=r"C:\\Users\\lenovo\\Desktop\\coco数据集\\val2017",annFile=r"C:\Users\lenovo\Desktop\coco数据集\annotations\instances_val2017.json")
image,info = coco_dataset[0]
image_hander = ImageDraw.ImageDraw(image)
for annotation in info:
    x_min,y_min,width,height = annotation['bbox']
    image_hander.rectangle(((x_min,y_min),(x_min+width,y_min+height)))
image.show()
```

## 4.猫狗识别系统

**1.导入相关库**

```py
import torch
import cv2
import numpy as np
import matplotlib.pyplot as plt
```

这里我们导入了几个关键库：

- **torch**: 用于加载和操作深度学习模型。`torch` 是 PyTorch 的核心库，提供张量计算和神经网络功能。
- **cv2**: OpenCV 库，用于处理图像的加载、显示、操作等。它提供了很多函数用于图像处理。
- **numpy**: 提供对数组和矩阵的支持，并且有很多科学计算工具。OpenCV 和 PyTorch 都与 numpy 数组密切交互。
- **matplotlib.pyplot**: 用于绘图和图像的显示，常用于数据可视化。

**2.加载预训练的 YOLOv5 模型**

```py
model = torch.hub.load('ultralytics/yolov5', 'yolov5s', pretrained=True)
```

这里使用 PyTorch 的 `torch.hub` 加载一个 YOLOv5 模型。YOLOv5 是一个基于深度学习的目标检测模型，它可以在图片或视频中识别多个目标。

- `torch.hub.load`: 这是 PyTorch 提供的加载预训练模型的接口。
- `'ultralytics/yolov5'`: YOLOv5 的仓库，模型来自于此。
- `'yolov5s'`: 代表 YOLOv5 的轻量版模型，模型越轻量，推理速度越快，但精度相对较低。你可以选择其他版本，比如 `'yolov5m'`（中等版本），`'yolov5l'`（大版本）和 `'yolov5x'`（超大版本）。
- `pretrained=True`: 加载一个已经在 COCO 数据集上预训练好的模型，省去了从头训练的过程。

**3.加载图片**

```py
image_path = r'C:\Yolov5\yolov5-master\test\test_new\121.jpg'  # 替换为你的图片路径
img = cv2.imread(image_path)
```

**`image_path`**: 图片的路径。

**`cv2.imread(image_path)`**: 使用 OpenCV 的 `imread` 函数从路径中读取图像，返回的是一个 numpy 数组，表示图像的像素值。

**4.使用模型进行推理**

```py
results = model(img)
```

**推理**: 指使用神经网络模型进行预测，给定输入图像，模型将返回检测结果。

**`model(img)`**: 使用 YOLOv5 模型对输入的图像 `img` 进行推理，返回的是一个 `results` 对象，包含检测框、类别和置信度等信息。

**5.打印检测结果**

```py
results.print()  # 输出检测结果
```

**`results.print()`**: 这个函数会将检测到的物体的类别、位置（边界框的坐标）和置信度输出到控制台，方便用户查看结果。

**6.保存检测结果**

```py
results.save()  # 保存结果到 runs/detect 目录
```

**`results.save()`**: 将检测后的图像结果保存到默认的 `runs/detect` 目录。图像文件包含了模型推理的结果（例如，标注的目标检测框）。

**7.显示检测结果**

```py
results.show()
```

**`results.show()`**: 调用此函数会使用默认的显示工具（如 `matplotlib`）来展示图像，并在图像上标注模型检测到的结果。

8.可视化并绘制边界框

```py
def visualize_results(image_path, results):
    img = cv2.imread(image_path)
    detections = results.xyxy[0]  # 获取检测结果
    for *box, conf, cls in detections:
        # 提取边界框坐标
        x1, y1, x2, y2 = map(int, box)

        # 在图片上绘制边界框
        label = f'{model.names[int(cls)]} {conf:.2f}'
        color = (255, 0, 0)  # 红色边框
        cv2.rectangle(img, (x1, y1), (x2, y2), color, 2)
        cv2.putText(img, label, (x1, y1 - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.9, color, 2)

    # 将结果显示出来
    plt.figure(figsize=(12, 8))
    plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
    plt.axis('off')
    plt.show()
```

#### 逐行解析：

1. **`def visualize_results(image_path, results):`**: 定义一个函数用于可视化 YOLOv5 的检测结果。输入参数为图像路径 `image_path` 和检测结果 `results`。
2. **`img = cv2.imread(image_path)`**: 重新加载图像，保证图像是原始的。
3. **`detections = results.xyxy[0]`**: 这里获取 YOLOv5 检测的结果。`results.xyxy` 返回的是所有检测框的坐标（x1, y1, x2, y2），以及置信度和类别。
4. **`for \*box, conf, cls in detections:`**: 遍历检测结果，分别获取每个检测框的坐标 `box`，置信度 `conf` 和类别 `cls`。
5. **`x1, y1, x2, y2 = map(int, box)`**: 提取边界框的四个坐标，并将它们转换为整数。
6. **`label = f'{model.names[int(cls)]} {conf:.2f}'`**: 生成标签字符串，包含物体类别名和置信度。`model.names` 是 YOLOv5 模型的类别名列表。
7. **`color = (255, 0, 0)`**: 定义边界框的颜色，红色。
8. **`cv2.rectangle(img, (x1, y1), (x2, y2), color, 2)`**: 在图像上绘制检测到的边界框。
9. **`cv2.putText(img, label, (x1, y1 - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.9, color, 2)`**: 在图像上方边界框绘制类别标签。
10. **`plt.figure(figsize=(12, 8))`**: 设置图像展示的尺寸。
11. **`plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))`**: 使用 `matplotlib` 显示图像，同时将 BGR 格式的图像转换为 RGB 格式。
12. **`plt.axis('off')`**: 关闭坐标轴。
13. **`plt.show()`**: 显示图像。

**调用可视化函数**

```py
visualize_results(image_path, results)
```

最后，调用我们定义的 `visualize_results` 函数来显示检测结果的图像，包含绘制好的边界框。
